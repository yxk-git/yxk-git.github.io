[{"title":"我的第一篇博客","date":"2019-07-04T13:52:00.000Z","path":"2019/07/04/我的第一篇博客/","text":"","tags":[]},{"title":"《第一篇博客》","date":"2019-07-02T15:05:57.103Z","path":"2019/07/02/hello-world/","text":"抽象类和继承继承(extends):子类自动拥有父类的所有非私有成员,可以直接调用.特点: 1.单一继承. 2.多层继承. 3.所有都直接或者间接继承Object类(根类). 注意: 1.若子类和父类的成员名相同时,优先调用子类成员(就近原则);若需要调用父类成员,使用super关键字. 2.当父类时抽象类时,子类需要重写父类中的所有抽象方法或者子类也声明为抽象类.抽象类(abstract)使用: 1.抽象类不能创建对象(不能实例化). 2.抽象类天生就是被继承的. 3.继承抽象类的子类必须重写父类的所有抽象方法,否则子类也是抽象类,使用abstract修饰. 注意: 1.抽象类不能创建对象. 2.抽象类中有构造方法. 3.抽象类中不一定有抽象方法,但是有抽象方法的类一定是抽象类. 4.子类需要重写抽象类中的所有抽象方法或者子类也声明为抽象类.Object类的介绍类Object是类层次结构的跟类。所有对象(包括数组)都有这个类的方法 #### a.toString 方法 public String toString();返回该对象的字符串表示。 1.默认的表示格式：包名.类名@地址值 2.在实际开发中需要重写toString方法；返回对象的属性值，而不是地址值 3.注意：toString方法并需要我们调用，我们只需要打印对象名，剩下的编译器会自动补全 #### b.equals 方法 public boolean equals(); 对象名.equals(Object obj); a.在Object类中,equals方法:默认比较是对象的地址值 b.在实际开发中,我们也会重写equals方法:比较两个对象的内容,而不是地址值 ###### == 与 equals 的区别 a.如果是基本类型:== 比较两个基本类型的数值 equals基本类型是没有的!!! b.如果是引用类型:== 比较两个对象的地址值 equals默认比较(Object类中)的也是地址值,如果重写了那就按照重写的规则比较Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]