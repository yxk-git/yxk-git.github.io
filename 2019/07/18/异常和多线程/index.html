<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="康帅傅的博客"><meta name="keywords" content="Java基础,JavaEE"><title>《异常和多线程》 | 念你是头猪</title><link rel="stylesheet" type="text/css" href="//fonts.loli.net/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style-dark.css?v=2.0.3"><link rel="stylesheet" type="text/css" href="/css/highlight-dark.css?v=2.0.3"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">《异常和多线程》</h1><a id="logo" href="/.">念你是头猪</a><p class="description">胸中自有青山在，何必随人看桃花。</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="搜索"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">《异常和多线程》</h1><div class="post-meta"><a href="/2019/07/18/异常和多线程/#comments" class="comment-count"></a><p><span class="date">Jul 18, 2019</span><span><i id="busuanzi_container_page_pv"><i id="busuanzi_value_page_pv"></i><i>点击</i></i></span></p></div><div class="post-content"><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>　　&gt;异常是程序出现问题(异常不是语法错误!!)</p>
<h4 id="异常的继承体系"><a href="#异常的继承体系" class="headerlink" title="异常的继承体系"></a>异常的继承体系</h4><blockquote>
<p>Throwable 异常的根类<br>　　|- Error 错误类(通常是系统引起)<br>　　|- Exception 异常类<br>　　　　|- 编译时异常:异常在编译时期就报错<br>　　　　　　&gt;Exception类以及其子类(RuntimeException除外)<br>　　　　|- 运行时异常:编译时期不会报错,运行时报错!<br>　　　　　　&gt;RuntimeException以及其子类</p>
</blockquote>
<h4 id="异常类中常用方法"><a href="#异常类中常用方法" class="headerlink" title="异常类中常用方法"></a>异常类中常用方法</h4><p>　　1.printStackTrace();打印异常对象中的详细信息(类型,原因,位置)<br>　　2.getMessage();获取异常对象中原因<br>　　3.toString();获取异常的类型和异常描述信息(不用)</p>
<h4 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h4><p>　　1.编译时异常:在编译时期报的异常<br>　　　　&gt;Exception类以及其子类(RuntimeException除外)<br>　　2.运行时异常:编译时期有异常也不报异常,运行时再报异常<br>　　　　&gt;RuntimeException以及其子类</p>
<h4 id="遇到异常的2种处理方式"><a href="#遇到异常的2种处理方式" class="headerlink" title="遇到异常的2种处理方式"></a>遇到异常的2种处理方式</h4><p>　　1.throws声明抛出异常<br>　　　　&gt;throws作用:形容词,声明某个方法可能抛出某种异常,要求调用者必须处理该异常</p>
<h4 id="当调用方法时-必须处理该异常"><a href="#当调用方法时-必须处理该异常" class="headerlink" title="当调用方法时(必须处理该异常)"></a>当调用方法时(必须处理该异常)</h4><p>　　1.不处理,再次向上声明抛出<br>　　2.try..catch捕获异常</p>
<blockquote>
<p>作用:可以使程序在局部出异常的情况下,整体正常运行</p>
</blockquote>
<h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p>　　&gt;finally不能单独使用</p>
<blockquote>
<p>作用:<br>　　 1.写在finally中的代码无论如何都会执行<br>　　 2.一般我们会在finally中写释放资源有关的代码<br>　　 3.释放资源,比如:关闭IO流,关闭数据类连接,关闭网络连接</p>
</blockquote>
<h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><p>　　1.为什么要自定义异常<br>　　　　&gt;因为JDK的异常不可能描述实际开发中所有的问题</p>
<blockquote>
<p>自定义异常的步骤<br>　　1.创建一个类,必须以Exception结尾<br>　　2.该类必须继承Excepton或者RuntimeException<br>　　3.异常类必须有至少两个构造:无参构造和String参数构造</p>
</blockquote>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>　　1.并行和并发<br>　　　　&gt;并行:两个事件在同一时刻都在发生<br>　　　　&gt;并发:两个事件在同一个时间段内都在发生<br>　　2.进程和线程<br>　　　　&gt;进程:正在运行的程序<br>　　　　&gt;线程:进程中完成某一个特定功能的执行单元</p>
<h4 id="进程和线程的一些区别-了解"><a href="#进程和线程的一些区别-了解" class="headerlink" title="进程和线程的一些区别(了解)"></a>进程和线程的一些区别(了解)</h4><p>　　&gt;每个进程拥有独立内存空间(独立栈和独立堆)<br>　　&gt;每个线程拥有独立的栈空间,堆空间是共享</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>　　&gt;就是CPU在多个线程之间进行快速的切换<br>　　&gt;线程调度分为两种:<br>　　　　1.分时调度:每个线程平均分配CPU的执行时间<br>　　　　2.抢占式调用:每个线程随机分配CPU的时间,具体的随机概率和优先级有关<br>　　　　　　&gt;优先级越高的抢到CPU的概率越高</p>
<blockquote>
<p>Java采用抢占式调度,Java程序运行时,默认至少有三个线程<br>　　1.main方法所在的线程,我们称为主线程<br>　　2.垃圾回收器所在的线程,垃圾回收线程<br>　　3.异常打印时也是一个线程,异常线程</p>
</blockquote>
<h3 id="线程类-Thread"><a href="#线程类-Thread" class="headerlink" title="线程类(Thread)"></a>线程类(Thread)</h3><p>　&gt;根据API的描述:<br>　　　　1.一种方法是将类声明为 Thread 的子类。<br>　　　　2.该子类应重写 Thread 类的 run 方法。<br>　　　　3.接下来可以分配并启动该子类的实例</p>
<h4 id="创建新线程方式一"><a href="#创建新线程方式一" class="headerlink" title="创建新线程方式一"></a>创建新线程方式一</h4><blockquote>
<p>步骤:<br>　　1.创建子类继承Thread<br>　　2.子类重写run方法(run方法内就是线程的任务代码)<br>　　3.创建子类的对象(其实一个线程对象)<br>　　4.启动线程(调用start方法)</p>
</blockquote>
<h4 id="多线程的内存分配："><a href="#多线程的内存分配：" class="headerlink" title="多线程的内存分配："></a>多线程的内存分配：</h4><p>　　1.一个Java程序就是一个进程,拥有独立的栈和堆<br>　　2.Java进程中每个线程都有独立的栈,共享整个进程的堆</p>
<h4 id="创建新线程方式二"><a href="#创建新线程方式二" class="headerlink" title="创建新线程方式二"></a>创建新线程方式二</h4><p>API描述:<br>　　1.另一种方法是声明实现 Runnable 接口的类。<br>　　2.该类然后实现 run 方法。然后可以分配该类的实例，<br>　　3.在创建 Thread 时作为一个参数来传递并启动。</p>
<blockquote>
<p>步骤:<br>　　1.创建实现类 实现 Runnable接口<br>　　2.重写接口中run方法<br>　　3.创建实现类的对象<br>　　4.创建Thread对象,传入实现类对象<br>　　5.调用Thread对象的start方法启动</p>
</blockquote>
<h4 id="两种创建线程方式的比较"><a href="#两种创建线程方式的比较" class="headerlink" title="两种创建线程方式的比较"></a>两种创建线程方式的比较</h4><p>　　1.继承方式只能单继承,实现方式弥补单继承的不足<br>　　2.继承方式线程对象和任务对象是紧紧耦合的,而实现方式线程对象和任务对象是解耦合的<br>　　3.以后我们用的线程池,提交时只能提交任务对象(Runnable/Callable),不提交线程对象</p>
<blockquote>
<p>总结:JDK强烈建议,尽量使用实现类方式创建线程</p>
</blockquote>
<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>　　&gt;线程安全问题出现的原因</p>
<blockquote>
<p>必须满足:<br>　　1.多线程同时运行<br>　　2.执行同一个任务<br>　　3.操作同一个共享数据</p>
</blockquote>
<h4 id="线程安全问题的演示-卖票案例"><a href="#线程安全问题的演示-卖票案例" class="headerlink" title="线程安全问题的演示:卖票案例"></a>线程安全问题的演示:卖票案例</h4><p>　　1.重复数据产生原因:<br>　　2.非法数据0,-1产生的原因:</p>
<h3 id="三种线程同步的方式"><a href="#三种线程同步的方式" class="headerlink" title="三种线程同步的方式"></a>三种线程同步的方式</h3><p>　　1.同步代码块(最常用的方式)</p>
<blockquote>
<p>格式:<br>　　synchronized(锁对象){<br>　　　　需要同步的那些代码<br>　　}<br>锁对象:可以是任意对象,但是必须是同一个对象</p>
</blockquote>
<h2 id="2-同步方法"><a href="#2-同步方法" class="headerlink" title="　　2.同步方法"></a>　　2.同步方法</h2><blockquote>
<p>格式:<br>　　public synchronized void method(){<br>　　　　需要同步的那些代码<br>　　}<br>注意:同步方法也是需要锁对象的,但是锁对象不需要我们提供,默认使用this<br>　　 如果同步方式是静态的,那么也需要锁,默认使用当前类的字节码文件</p>
</blockquote>
<h2 id="3-Lock锁"><a href="#3-Lock锁" class="headerlink" title="　　3.Lock锁"></a>　　3.Lock锁</h2><blockquote>
<p>格式:<br>　　Lock lock = new ReentrantLock();<br>　　lock.lock();<br>　　　　需要同步的那些代码<br>　　lock.unlock();</p>
</blockquote>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><blockquote>
<p>线程的六种状态<br>　　1.新建状态(New)<br>　　　　刚刚创建,但是没有启动的线程<br>　　2.可运行状态(Runnable)<br>　　　　新建状态的线程,调用了启动方法<br>　　3.锁阻塞状态(Blocked)<br>　　　　当前需要锁,但是锁被其他线程持有<br>　　4.限时等待状态(Timed_waiting)<br>　　　　在线程中调用Thread.sleep(毫秒值)<br>　　5.无限等待状态(Waiting)<br>　　　　a.线程如何进入Waiting(无线等待状态)<br>　　　　　　1.当前线程必须先持有锁对象<br>　　　　　　2.调用锁对象的wait()方法 – 线程就可以进入无限等待了<br>　　　　　　3.当前线程进入无限等待之前,先自动释放锁对象<br>　　　　b.其他线程如何唤醒Waiting状态的线程<br>　　　　　　1.其他线程也需要持有锁(必须和无限等待线程释放的锁是    同一个锁对象)<br>　　　　　　2.调用锁对象的notify()方法 – 唤醒无限等待中的那个线程<br>　　　　　　3.被唤醒线程会进入锁阻塞状态,直到再次持有同一个锁对象,才可进入运行状态<br>　　6.消亡状态(Terminated)</p>
</blockquote>
</div><div class="post-copyright"><blockquote><p>原文作者: 康帅傅</p><p>原文链接: <a href="https://yxk-git.github.io/2019/07/18/异常和多线程/">https://yxk-git.github.io/2019/07/18/异常和多线程/</a></p><p>版权声明: 转载请注明出处(必须保留原文作者署名原文链接)</p></blockquote></div><div class="tags"></div><div class="post-share"><div class="social-share"><span>分享到:</span></div></div><div class="post-nav"><a href="/2019/07/18/常用API/" class="next">《常用API》</a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NTA4MS8yMTU5OA=="></div></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#异常"><span class="toc-number">1.</span> <span class="toc-text">异常</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#异常的继承体系"><span class="toc-number">1.1.</span> <span class="toc-text">异常的继承体系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常类中常用方法"><span class="toc-number">1.2.</span> <span class="toc-text">异常类中常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常的分类"><span class="toc-number">1.3.</span> <span class="toc-text">异常的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遇到异常的2种处理方式"><span class="toc-number">1.4.</span> <span class="toc-text">遇到异常的2种处理方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#当调用方法时-必须处理该异常"><span class="toc-number">1.5.</span> <span class="toc-text">当调用方法时(必须处理该异常)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#finally代码块"><span class="toc-number">2.</span> <span class="toc-text">finally代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义异常"><span class="toc-number">3.</span> <span class="toc-text">自定义异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多线程"><span class="toc-number">4.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#进程和线程的一些区别-了解"><span class="toc-number">4.1.</span> <span class="toc-text">进程和线程的一些区别(了解)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程调度"><span class="toc-number">4.2.</span> <span class="toc-text">线程调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程类-Thread"><span class="toc-number">5.</span> <span class="toc-text">线程类(Thread)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建新线程方式一"><span class="toc-number">5.1.</span> <span class="toc-text">创建新线程方式一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多线程的内存分配："><span class="toc-number">5.2.</span> <span class="toc-text">多线程的内存分配：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创建新线程方式二"><span class="toc-number">5.3.</span> <span class="toc-text">创建新线程方式二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#两种创建线程方式的比较"><span class="toc-number">5.4.</span> <span class="toc-text">两种创建线程方式的比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程安全"><span class="toc-number">6.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全问题的演示-卖票案例"><span class="toc-number">6.1.</span> <span class="toc-text">线程安全问题的演示:卖票案例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种线程同步的方式"><span class="toc-number">7.</span> <span class="toc-text">三种线程同步的方式</span></a></li></ol><li class="toc-item toc-level-2"><a class="toc-link" href="#2-同步方法"><span class="toc-number"></span> <span class="toc-text">　　2.同步方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Lock锁"><span class="toc-number"></span> <span class="toc-text">　　3.Lock锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#线程的状态"><span class="toc-number">1.</span> <span class="toc-text">线程的状态</span></a></li></ol></li></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/异常和多线程/">《异常和多线程》</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/常用API/">《常用API》</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/final、static关键字和内部类/">《final、static关键字和内部类》</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/接口和多态/">《接口和多态》</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/07/18/继承和抽象类/">《继承、抽象类和Object类》</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">七月 2019</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><a href="/baidusitemap.xml">网站地图</a> |  <a href="/atom.xml">订阅本站</a> |  <a href="/about/">联系博主</a></p><p>本站总访问量：<i id="busuanzi_container_site_pv"><i id="busuanzi_value_site_pv"></i></i>次，本站总访客数:<i id="busuanzi_container_site_uv"><i id="busuanzi_value_site_uv"></i></i>人</p><p><span> Copyright &copy;<a href="/." rel="nofollow">康帅傅.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Count by<a href="http://busuanzi.ibruce.info/"> busuanzi.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><script type="text/javascript" src="/js/search.json.js?v=2.0.3"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.3" async></script><link rel="stylesheet" type="text/css" href="/share/css/share.css"><script type="text/javascript" src="/share/js/social-share.js" charset="utf-8"></script><script type="text/javascript" src="/share/js/qrcode.js" charset="utf-8"></script><script>(function(d, s) {
  var j, e = d.getElementsByTagName('body')[0];
  if (typeof LivereTower === 'function') { return; }
  j = d.createElement(s);
  j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
  j.async = true;
  e.appendChild(j);
})(document, 'script');
</script></body></html>